#!/usr/bin/env python3
# -*- coding: utf-8 -*-

###############################################################################
# STM32CubeMX Makefile 自动修复脚本
# 
# 功能：自动更新 STM32CubeMX 生成的 Makefile，使其支持 macOS 环境
#       主要修复：工具链路径配置，支持环境变量 ARM_TOOLCHAIN_PATH
#
# 使用方法：
#   python3 fix_cubemx_makefile.py [Makefile路径]
#   如果不指定路径，默认使用当前目录的 Makefile
#
# 作者：Auto-generated
# 日期：2025年12月
###############################################################################

import sys
import os
import re
from datetime import datetime
from pathlib import Path

# 颜色输出
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

def print_info(msg):
    print(f"{Colors.BLUE}[INFO]{Colors.NC} {msg}")

def print_success(msg):
    print(f"{Colors.GREEN}[SUCCESS]{Colors.NC} {msg}")

def print_warning(msg):
    print(f"{Colors.YELLOW}[WARNING]{Colors.NC} {msg}")

def print_error(msg):
    print(f"{Colors.RED}[ERROR]{Colors.NC} {msg}")

def is_cubemx_makefile(filepath):
    """检查是否是 STM32CubeMX 生成的 Makefile"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            # 检查 STM32CubeMX 特征
            if 'File automatically-generated by tool: [projectgenerator]' in content:
                return True
            # 或者检查典型的 STM32CubeMX 结构
            if 'PREFIX = arm-none-eabi-' in content and 'GCC_PATH' in content:
                return True
            return False
    except Exception as e:
        print_error(f"读取文件失败: {e}")
        return False

def is_already_fixed(filepath):
    """检查是否已经修复过"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return 'ARM_TOOLCHAIN_PATH' in f.read()
    except:
        return False

def backup_file(filepath):
    """备份文件"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_path = f"{filepath}.backup.{timestamp}"
    try:
        import shutil
        shutil.copy2(filepath, backup_path)
        return backup_path
    except Exception as e:
        print_error(f"备份失败: {e}")
        return None

def fix_makefile(filepath):
    """修复 Makefile"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            lines = content.splitlines(True)
    except Exception as e:
        print_error(f"读取文件失败: {e}")
        return False
    
    # 查找 PREFIX 定义的位置
    prefix_line = -1
    for i, line in enumerate(lines):
        if re.match(r'^\s*PREFIX\s*=\s*arm-none-eabi-', line):
            prefix_line = i
            break
    
    if prefix_line == -1:
        print_error("无法找到 PREFIX 定义，可能不是标准的 STM32CubeMX Makefile")
        return False
    
    print_info(f"找到 PREFIX 定义在第 {prefix_line + 1} 行")
    
    # 查找 binaries 部分开始（在 PREFIX 之前）
    binaries_start = -1
    for i in range(prefix_line, -1, -1):
        if '# binaries' in lines[i] or '#######################################' in lines[i]:
            binaries_start = i
            break
    
    if binaries_start != -1:
        print_info(f"找到 binaries 部分标题在第 {binaries_start + 1} 行")
    
    # 查找工具链配置部分的结束位置
    # 策略：查找从 PREFIX 开始到工具链命令定义结束的所有行
    # 典型的 STM32CubeMX 结构：
    #   PREFIX = arm-none-eabi-
    #   ifdef GCC_PATH
    #   CC = $(GCC_PATH)/$(PREFIX)gcc
    #   AS = ...
    #   CP = ...
    #   SZ = ...
    #   else
    #   CC = $(PREFIX)gcc
    #   AS = ...
    #   CP = ...
    #   SZ = ...
    #   endif
    #   HEX = ...
    #   BIN = ...
    
    # 查找 ifdef GCC_PATH 和对应的 endif
    gcc_path_start = -1
    gcc_path_end = -1
    else_line = -1
    
    # 首先查找 ifdef GCC_PATH
    for i in range(prefix_line, min(prefix_line + 50, len(lines))):
        if 'ifdef GCC_PATH' in lines[i]:
            gcc_path_start = i
            break
    
    # 如果找到 ifdef，查找对应的 else 和 endif
    if gcc_path_start != -1:
        print_info(f"找到 ifdef GCC_PATH 在第 {gcc_path_start + 1} 行")
        # 查找 else
        for i in range(gcc_path_start + 1, min(gcc_path_start + 30, len(lines))):
            if re.match(r'^\s*else\s*$', lines[i]):
                else_line = i
                break
        # 查找 endif
        if else_line != -1:
            for i in range(else_line + 1, min(else_line + 20, len(lines))):
                if re.match(r'^\s*endif\s*$', lines[i]):
                    gcc_path_end = i
                    break
        else:
            # 没有 else，直接找 endif
            for i in range(gcc_path_start + 1, min(gcc_path_start + 20, len(lines))):
                if re.match(r'^\s*endif\s*$', lines[i]):
                    gcc_path_end = i
                    break
    
    # 如果没有找到 GCC_PATH 部分，查找下一个重要标记
    if gcc_path_end == -1:
        # 查找 HEX 或 BIN 定义（这些通常在工具链配置之后）
        for i in range(prefix_line + 1, min(prefix_line + 30, len(lines))):
            if re.match(r'^\s*HEX\s*=', lines[i]) or re.match(r'^\s*BIN\s*=', lines[i]):
                gcc_path_end = i - 1
                print_info(f"通过 HEX/BIN 定义定位，工具链配置结束于第 {gcc_path_end + 1} 行")
                break
        
        # 如果还是没找到，查找空行或注释行（作为分隔符）
        if gcc_path_end == -1:
            for i in range(prefix_line + 1, min(prefix_line + 25, len(lines))):
                # 跳过工具链命令定义行
                if re.match(r'^\s*(CC|AS|CP|SZ)\s*=', lines[i]):
                    continue
                # 如果遇到空行或注释行，且前面有工具链定义
                if (lines[i].strip() == '' or lines[i].strip().startswith('#')) and i > prefix_line + 3:
                    gcc_path_end = i - 1
                    print_info(f"通过空行/注释定位，工具链配置结束于第 {gcc_path_end + 1} 行")
                    break
    
    # 如果还是没找到，使用默认范围（但给出警告）
    if gcc_path_end == -1:
        gcc_path_end = prefix_line + 15
        print_warning(f"无法准确定位工具链配置结束位置，使用默认范围（第 {gcc_path_end + 1} 行）")
    
    print_info(f"工具链配置部分：第 {prefix_line + 1} 行 到 第 {gcc_path_end + 1} 行")
    
    # 生成新的配置
    new_config = '''# 工具链路径配置（优先级：环境变量 > GCC_PATH > 系统 PATH）
# 优先级1：使用环境变量指定的工具链（推荐，支持全局配置）
ifdef ARM_TOOLCHAIN_PATH
    # 使用环境变量指定的工具链（推荐）
    TOOLCHAIN_DIR = $(ARM_TOOLCHAIN_PATH)
    PREFIX = $(TOOLCHAIN_DIR)/bin/arm-none-eabi-
    $(info Using toolchain from environment: $(TOOLCHAIN_DIR))
else ifdef GCC_PATH
    # 使用 GCC_PATH 变量指定的路径（兼容原有方式）
    TOOLCHAIN_DIR = $(GCC_PATH)
    PREFIX = $(TOOLCHAIN_DIR)/$(if $(findstring /bin,$(GCC_PATH)),,bin/)arm-none-eabi-
    $(info Using toolchain from GCC_PATH: $(TOOLCHAIN_DIR))
else
    # 使用系统 PATH 中的工具链（可能缺少 newlib）
    PREFIX = arm-none-eabi-
    TOOLCHAIN_DIR = 
    $(info Using toolchain from system PATH)
    $(warning WARNING: Using system PATH toolchain. If compilation fails, set ARM_TOOLCHAIN_PATH environment variable.)
    # 验证工具链是否存在
    ifeq ($(shell which $(PREFIX)gcc),)
        $(error Cannot find ARM toolchain. Please set ARM_TOOLCHAIN_PATH environment variable or place toolchain in ../toolchain)
    endif
endif

CC = $(PREFIX)gcc
AS = $(PREFIX)gcc -x assembler-with-cpp
CP = $(PREFIX)objcopy
SZ = $(PREFIX)size
'''
    
    # 构建新的文件内容
    new_lines = []
    
    # 保留 PREFIX 之前的内容（包括 binaries 部分标题）
    if binaries_start != -1:
        new_lines.extend(lines[:binaries_start + 1])
        print_info(f"保留 binaries 部分标题之前的内容（{binaries_start + 1} 行）")
    else:
        new_lines.extend(lines[:prefix_line])
        print_info(f"保留 PREFIX 之前的内容（{prefix_line} 行）")
    
    # 添加新的配置
    new_lines.extend(new_config.splitlines(True))
    print_info("已添加新的工具链配置")
    
    # 跳过原有的工具链配置部分，找到下一个重要部分
    skip_end = gcc_path_end
    
    # 查找下一个重要部分（HEX, BIN, 或新的章节）
    # 需要跳过所有原有的工具链相关定义
    found_next_section = False
    skip_count = 0
    
    for i in range(skip_end + 1, len(lines)):
        line = lines[i]
        stripped = line.strip()
        
        # 跳过原有的 CC, AS, CP, SZ 定义（可能在 ifdef 块内或块外）
        if re.match(r'^\s*(CC|AS|CP|SZ)\s*=', line):
            skip_count += 1
            continue
        
        # 跳过 ifdef/else/endif 行（如果还没处理完）
        if re.match(r'^\s*(ifdef|else|endif)\s', line):
            skip_count += 1
            continue
        
        # 如果遇到 HEX 或 BIN 定义，说明已经过了工具链配置部分
        if re.match(r'^\s*(HEX|BIN)\s*=', line):
            new_lines.extend(lines[i:])
            found_next_section = True
            print_info(f"找到 HEX/BIN 定义，从第 {i + 1} 行开始保留后续内容（跳过了 {skip_count} 行）")
            break
        
        # 如果遇到新的章节标题（多个 # 号）
        if '#######################################' in line and i > skip_end + 3:
            new_lines.extend(lines[i:])
            found_next_section = True
            print_info(f"找到新的章节标题，从第 {i + 1} 行开始保留后续内容（跳过了 {skip_count} 行）")
            break
        
        # 如果遇到 CFLAGS 或其他编译选项定义（说明已经过了工具链部分）
        if re.match(r'^\s*(CFLAGS|LDFLAGS|ASFLAGS)\s*=', line) and i > skip_end + 5:
            new_lines.extend(lines[i:])
            found_next_section = True
            print_info(f"找到编译选项定义，从第 {i + 1} 行开始保留后续内容（跳过了 {skip_count} 行）")
            break
    
    # 如果没有找到明显的分界，保留 skip_end 之后的所有行（跳过工具链相关）
    if not found_next_section:
        print_warning("未找到明显的分界标记，将保留所有后续内容（跳过工具链相关行）")
        for i in range(skip_end + 1, len(lines)):
            line = lines[i]
            # 跳过原有的工具链命令定义和 ifdef/else/endif
            if (re.match(r'^\s*(CC|AS|CP|SZ)\s*=', line) or 
                re.match(r'^\s*(ifdef|else|endif)\s', line)):
                skip_count += 1
                continue
            new_lines.append(line)
        if skip_count > 0:
            print_info(f"跳过了 {skip_count} 行工具链相关定义")
    
    # 写入文件
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            f.writelines(new_lines)
        return True
    except Exception as e:
        print_error(f"写入文件失败: {e}")
        return False

def check_environment():
    """检查环境变量"""
    arm_toolchain = os.environ.get('ARM_TOOLCHAIN_PATH')
    if not arm_toolchain:
        print_warning("环境变量 ARM_TOOLCHAIN_PATH 未设置")
        print_info("建议执行以下命令：")
        print("  export ARM_TOOLCHAIN_PATH=\"$HOME/toolchains/arm-gnu-toolchain-14.2.1\"")
        print("  # 或添加到 ~/.zshrc 或 ~/.bashrc")
        print()
        response = input("是否继续修复 Makefile？(y/n): ")
        if response.lower() != 'y':
            return False
    else:
        print_success(f"环境变量已设置: {arm_toolchain}")
        toolchain_gcc = os.path.join(arm_toolchain, 'bin', 'arm-none-eabi-gcc')
        if not os.path.exists(toolchain_gcc):
            print_warning("工具链文件不存在，请检查路径是否正确")
    return True

def main():
    """主函数"""
    print_info("=" * 50)
    print_info("STM32CubeMX Makefile 自动修复工具")
    print_info("=" * 50)
    print()
    
    # 获取 Makefile 路径
    if len(sys.argv) > 1:
        makefile_path = sys.argv[1]
    else:
        makefile_path = 'Makefile'
    
    # 检查文件是否存在
    if not os.path.exists(makefile_path):
        print_error(f"文件不存在: {makefile_path}")
        sys.exit(1)
    
    # 检查是否是 STM32CubeMX 生成的
    if not is_cubemx_makefile(makefile_path):
        print_warning("这可能不是 STM32CubeMX 生成的 Makefile")
        response = input("是否继续？(y/n): ")
        if response.lower() != 'y':
            sys.exit(0)
    
    # 检查是否已经修复过
    if is_already_fixed(makefile_path):
        print_warning("Makefile 似乎已经修复过（包含 ARM_TOOLCHAIN_PATH）")
        response = input("是否重新修复？(y/n): ")
        if response.lower() != 'y':
            sys.exit(0)
    
    # 检查环境变量
    if not check_environment():
        sys.exit(0)
    
    # 备份文件
    backup_path = backup_file(makefile_path)
    if backup_path:
        print_info(f"已备份原文件到: {backup_path}")
    
    # 修复 Makefile
    print_info(f"开始修复 Makefile: {makefile_path}")
    if fix_makefile(makefile_path):
        print_success("Makefile 修复完成！")
        if backup_path:
            print_info(f"备份文件: {backup_path}")
        print()
        print_success("修复完成！")
        print_info("现在可以尝试编译：")
        print("  make")
        print()
        print_info("如果环境变量未设置，请执行：")
        print("  export ARM_TOOLCHAIN_PATH=\"$HOME/toolchains/arm-gnu-toolchain-14.2.1\"")
        print("  source ~/.zshrc  # 或 ~/.bashrc")
    else:
        print_error("修复失败")
        sys.exit(1)

if __name__ == '__main__':
    main()

